// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"plant-watering/ent/predicate"
	"plant-watering/ent/waterlog"
	"time"

	"github.com/google/uuid"
)

// WaterLogWhereInput represents a where input for filtering WaterLog queries.
type WaterLogWhereInput struct {
	Predicates []predicate.WaterLog  `json:"-"`
	Not        *WaterLogWhereInput   `json:"not,omitempty"`
	Or         []*WaterLogWhereInput `json:"or,omitempty"`
	And        []*WaterLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "seconds" field predicates.
	Seconds      *int32  `json:"seconds,omitempty"`
	SecondsNEQ   *int32  `json:"secondsNEQ,omitempty"`
	SecondsIn    []int32 `json:"secondsIn,omitempty"`
	SecondsNotIn []int32 `json:"secondsNotIn,omitempty"`
	SecondsGT    *int32  `json:"secondsGT,omitempty"`
	SecondsGTE   *int32  `json:"secondsGTE,omitempty"`
	SecondsLT    *int32  `json:"secondsLT,omitempty"`
	SecondsLTE   *int32  `json:"secondsLTE,omitempty"`

	// "channel" field predicates.
	Channel             *string  `json:"channel,omitempty"`
	ChannelNEQ          *string  `json:"channelNEQ,omitempty"`
	ChannelIn           []string `json:"channelIn,omitempty"`
	ChannelNotIn        []string `json:"channelNotIn,omitempty"`
	ChannelGT           *string  `json:"channelGT,omitempty"`
	ChannelGTE          *string  `json:"channelGTE,omitempty"`
	ChannelLT           *string  `json:"channelLT,omitempty"`
	ChannelLTE          *string  `json:"channelLTE,omitempty"`
	ChannelContains     *string  `json:"channelContains,omitempty"`
	ChannelHasPrefix    *string  `json:"channelHasPrefix,omitempty"`
	ChannelHasSuffix    *string  `json:"channelHasSuffix,omitempty"`
	ChannelEqualFold    *string  `json:"channelEqualFold,omitempty"`
	ChannelContainsFold *string  `json:"channelContainsFold,omitempty"`

	// "manual" field predicates.
	Manual    *bool `json:"manual,omitempty"`
	ManualNEQ *bool `json:"manualNEQ,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WaterLogWhereInput) AddPredicates(predicates ...predicate.WaterLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WaterLogWhereInput filter on the WaterLogQuery builder.
func (i *WaterLogWhereInput) Filter(q *WaterLogQuery) (*WaterLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWaterLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWaterLogWhereInput is returned in case the WaterLogWhereInput is empty.
var ErrEmptyWaterLogWhereInput = errors.New("ent: empty predicate WaterLogWhereInput")

// P returns a predicate for filtering waterlogs.
// An error is returned if the input is empty or invalid.
func (i *WaterLogWhereInput) P() (predicate.WaterLog, error) {
	var predicates []predicate.WaterLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, waterlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WaterLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, waterlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WaterLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, waterlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, waterlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, waterlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, waterlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, waterlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, waterlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, waterlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, waterlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, waterlog.IDLTE(*i.IDLTE))
	}
	if i.Seconds != nil {
		predicates = append(predicates, waterlog.SecondsEQ(*i.Seconds))
	}
	if i.SecondsNEQ != nil {
		predicates = append(predicates, waterlog.SecondsNEQ(*i.SecondsNEQ))
	}
	if len(i.SecondsIn) > 0 {
		predicates = append(predicates, waterlog.SecondsIn(i.SecondsIn...))
	}
	if len(i.SecondsNotIn) > 0 {
		predicates = append(predicates, waterlog.SecondsNotIn(i.SecondsNotIn...))
	}
	if i.SecondsGT != nil {
		predicates = append(predicates, waterlog.SecondsGT(*i.SecondsGT))
	}
	if i.SecondsGTE != nil {
		predicates = append(predicates, waterlog.SecondsGTE(*i.SecondsGTE))
	}
	if i.SecondsLT != nil {
		predicates = append(predicates, waterlog.SecondsLT(*i.SecondsLT))
	}
	if i.SecondsLTE != nil {
		predicates = append(predicates, waterlog.SecondsLTE(*i.SecondsLTE))
	}
	if i.Channel != nil {
		predicates = append(predicates, waterlog.ChannelEQ(*i.Channel))
	}
	if i.ChannelNEQ != nil {
		predicates = append(predicates, waterlog.ChannelNEQ(*i.ChannelNEQ))
	}
	if len(i.ChannelIn) > 0 {
		predicates = append(predicates, waterlog.ChannelIn(i.ChannelIn...))
	}
	if len(i.ChannelNotIn) > 0 {
		predicates = append(predicates, waterlog.ChannelNotIn(i.ChannelNotIn...))
	}
	if i.ChannelGT != nil {
		predicates = append(predicates, waterlog.ChannelGT(*i.ChannelGT))
	}
	if i.ChannelGTE != nil {
		predicates = append(predicates, waterlog.ChannelGTE(*i.ChannelGTE))
	}
	if i.ChannelLT != nil {
		predicates = append(predicates, waterlog.ChannelLT(*i.ChannelLT))
	}
	if i.ChannelLTE != nil {
		predicates = append(predicates, waterlog.ChannelLTE(*i.ChannelLTE))
	}
	if i.ChannelContains != nil {
		predicates = append(predicates, waterlog.ChannelContains(*i.ChannelContains))
	}
	if i.ChannelHasPrefix != nil {
		predicates = append(predicates, waterlog.ChannelHasPrefix(*i.ChannelHasPrefix))
	}
	if i.ChannelHasSuffix != nil {
		predicates = append(predicates, waterlog.ChannelHasSuffix(*i.ChannelHasSuffix))
	}
	if i.ChannelEqualFold != nil {
		predicates = append(predicates, waterlog.ChannelEqualFold(*i.ChannelEqualFold))
	}
	if i.ChannelContainsFold != nil {
		predicates = append(predicates, waterlog.ChannelContainsFold(*i.ChannelContainsFold))
	}
	if i.Manual != nil {
		predicates = append(predicates, waterlog.ManualEQ(*i.Manual))
	}
	if i.ManualNEQ != nil {
		predicates = append(predicates, waterlog.ManualNEQ(*i.ManualNEQ))
	}
	if i.Time != nil {
		predicates = append(predicates, waterlog.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, waterlog.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, waterlog.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, waterlog.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, waterlog.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, waterlog.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, waterlog.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, waterlog.TimeLTE(*i.TimeLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWaterLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return waterlog.And(predicates...), nil
	}
}
